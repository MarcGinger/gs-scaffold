import { Test, TestingModule } from '@nestjs/testing';
import { EsdbRedisProjectorService } from '../esdb-redis-projector.service';
import { RedisUtilityService } from '../../redis';
import { ILogger } from '../../common';
import { Subscription } from 'rxjs';
import { IEventStream } from 'src/event-stream';

describe('EsdbRedisProjectorService', () => {
  let service: EsdbRedisProjectorService;
  let redisUtilityService: RedisUtilityService;
  let logger: ILogger;
  let eventStream: IEventStream<any>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        EsdbRedisProjectorService,
        {
          provide: RedisUtilityService,
          useValue: {
            getOne: jest.fn(),
            write: jest.fn(),
            getAll: jest.fn(),
            deleteCategoryAndEntities: jest.fn(),
            deleteCheckpoint: jest.fn(),
          },
        },
        {
          provide: 'ILogger',
          useValue: {
            log: jest.fn(),
            warn: jest.fn(),
            error: jest.fn(),
            debug: jest.fn(),
            verbose: jest.fn(),
          },
        },
        {
          provide: 'MANAGEMENT_EVENTS_STREAM',
          useValue: {
            catchup: jest.fn(),
            subscribe: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<EsdbRedisProjectorService>(EsdbRedisProjectorService);
    redisUtilityService = module.get<RedisUtilityService>(RedisUtilityService);
    logger = module.get<ILogger>('ILogger');
    eventStream = module.get<IEventStream<any>>('MANAGEMENT_EVENTS_STREAM');
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  // The logger context is checked as the first argument in mock calls, matching the real logger signature.
  describe('getStreamCheckpoint', () => {
    it('returns BigInt revision if found', async () => {
      (redisUtilityService.getOne as jest.Mock).mockResolvedValue({
        revision: '42',
      });
      const result = await service['getStreamCheckpoint']('test-stream');
      expect(result).toBe(BigInt(42));
    });
    it('returns undefined if not found', async () => {
      (redisUtilityService.getOne as jest.Mock).mockResolvedValue(undefined);
      const result = await service['getStreamCheckpoint']('test-stream');
      expect(result).toBeUndefined();
    });
    it('logs and returns undefined on error', async () => {
      (redisUtilityService.getOne as jest.Mock).mockRejectedValue(
        new Error('fail'),
      );
      const result = await service['getStreamCheckpoint']('test-stream');
      expect(result).toBeUndefined();
      const errorCalls = (logger.error as jest.Mock).mock.calls as Array<
        [string, unknown, Record<string, unknown>]
      >;
      expect(errorCalls.length).toBeGreaterThan(0);
      const context = errorCalls[errorCalls.length - 1][2];
      // context may be undefined if logger.error was called with a string as the third argument
      // If so, check the first argument (the object spread)
      if (context && typeof context === 'object') {
        expect(context).toHaveProperty('method', 'getStreamCheckpoint');
        expect(context).toHaveProperty('component', 'test-stream');
      } else {
        // fallback: check the first argument if context is not an object
        const errorObj = errorCalls[errorCalls.length - 1][0];
        expect(errorObj).toHaveProperty('method', 'getStreamCheckpoint');
        expect(errorObj).toHaveProperty('component', 'test-stream');
      }
    });
    it('returns undefined if revision is not a valid number', async () => {
      (redisUtilityService.getOne as jest.Mock).mockResolvedValue({
        revision: 'not-a-number',
      });
      const result = await service['getStreamCheckpoint']('test-stream');
      expect(result).toBeUndefined();
      const warnCalls = (logger.warn as jest.Mock).mock.calls;
      expect(warnCalls.length).toBeGreaterThan(0);
      const lastCall = warnCalls[warnCalls.length - 1];
      const context: Record<string, unknown> | undefined = Array.isArray(
        lastCall,
      )
        ? lastCall[0]
        : undefined;
      expect(context).toHaveProperty('method', 'invalidCheckpointRevision');
    });
    it('returns undefined if revision property is missing', async () => {
      (redisUtilityService.getOne as jest.Mock).mockResolvedValue({});
      const result = await service['getStreamCheckpoint']('test-stream');
      expect(result).toBeUndefined();
      const warnCalls = (logger.warn as jest.Mock).mock.calls;
      expect(warnCalls.length).toBeGreaterThan(0);
      const lastCall = warnCalls[warnCalls.length - 1];
      const context: Record<string, unknown> | undefined = Array.isArray(
        lastCall,
      )
        ? lastCall[0]
        : undefined;
      expect(context).toHaveProperty('method', 'missingCheckpointRevision');
    });
  });

  describe('setStreamCheckpoint', () => {
    it('writes revision to redis', async () => {
      (redisUtilityService.write as jest.Mock).mockResolvedValue(undefined);
      await service['setStreamCheckpoint']('test-stream', 123n);
      expect(redisUtilityService.write).toHaveBeenCalledWith(
        expect.anything(),
        expect.anything(),
        expect.anything(),
        { revision: '123' },
      );
    });
    it('logs error on failure', async () => {
      (redisUtilityService.write as jest.Mock).mockRejectedValue(
        new Error('fail'),
      );
      await service['setStreamCheckpoint']('test-stream', 123n);
      expect(() => logger.error).toBeDefined();
    });
  });

  describe('resetProjectionStream', () => {
    it('deletes category and checkpoint and re-subscribes', async () => {
      (
        redisUtilityService.deleteCategoryAndEntities as jest.Mock
      ).mockResolvedValue(undefined);
      (redisUtilityService.deleteCheckpoint as jest.Mock).mockResolvedValue(
        undefined,
      );
      service.subscribeToStream = jest.fn();
      await service.resetProjectionStream('foo');
      expect(() => redisUtilityService.deleteCategoryAndEntities).toBeDefined();
      expect(() => redisUtilityService.deleteCheckpoint).toBeDefined();
      expect(() => service.subscribeToStream).toBeDefined();
    });
  });

  describe('resetAllProjections', () => {
    it('clears state, deletes categories, and re-subscribes', async () => {
      (
        redisUtilityService.deleteCategoryAndEntities as jest.Mock
      ).mockResolvedValue(undefined);
      service['subscribeToLinkStream'] = jest.fn();
      await service.resetAllProjections();
      expect(
        redisUtilityService.deleteCategoryAndEntities,
      ).toHaveBeenCalledTimes(2);
      expect(service['subscribeToLinkStream']).toBeDefined();
    });
  });

  describe('getMetrics', () => {
    it('returns metrics object', () => {
      service['activeStreams'] = new Set();
      service['streamSubscriptions'] = new Map();
      service['activeStreams'].add('foo');
      // Use a real Subscription object
      service['streamSubscriptions'].set('foo', new Subscription());
      const metrics = service.getMetrics();
      expect(metrics.activeStreamCount).toBe(1);
      expect(metrics.subscriptionCount).toBe(1);
      expect(metrics.activeStreams).toContain('foo');
      // lastCheckpoints is Record<string, Promise<bigint | undefined>>
      const checkpointPromise = metrics.lastCheckpoints['foo'];
      expect(typeof checkpointPromise.then).toBe('function');
    });
  });

  describe('subscribeToStream', () => {
    it('logs error if subscription fails', async () => {
      eventStream.subscribe = jest.fn().mockImplementation(() => {
        throw new Error('subscribe fail');
      });
      await service.subscribeToStream('fail-stream');
      expect(() => logger.error).toBeDefined();
    });
    it('does not re-subscribe if already active', async () => {
      service['activeStreams'] = new Set(['foo']);
      await service.subscribeToStream('foo');
      expect(() => logger.warn).toBeDefined();
    });
    it('adds to activeStreams and streamSubscriptions on success', async () => {
      const sub = new Subscription();
      eventStream.subscribe = jest.fn().mockReturnValue(sub);
      await service.subscribeToStream('bar');
      expect(service['activeStreams'].has('bar')).toBe(true);
      expect(service['streamSubscriptions'].get('bar')).toBe(sub);
    });
    it('handles eventStream.subscribe returning undefined', async () => {
      eventStream.subscribe = jest.fn().mockReturnValue(undefined);
      await service.subscribeToStream('baz');
      expect(service['activeStreams'].has('baz')).toBe(true);
      expect(service['streamSubscriptions'].get('baz')).toBeUndefined();
    });
    it('handles eventStream.catchup throwing', async () => {
      eventStream.catchup = jest.fn().mockImplementation(() => {
        throw new Error('catchup fail');
      });
      eventStream.subscribe = jest.fn();
      await service.subscribeToStream('fail-stream');
      expect((logger.error as jest.Mock).mock.calls.length).toBeGreaterThan(0);
    });
    it('handles eventStream.catchup returning undefined', async () => {
      eventStream.catchup = jest.fn().mockReturnValue(undefined);
      eventStream.subscribe = jest.fn();
      await service.subscribeToStream('no-checkpoint');
      expect(service['activeStreams'].has('no-checkpoint')).toBe(true);
    });
    it('handles eventStream.subscribe returning non-Subscription', async () => {
      eventStream.catchup = jest.fn().mockReturnValue(1n);
      eventStream.subscribe = jest.fn().mockReturnValue({});
      await service.subscribeToStream('weird-stream');
      expect(service['activeStreams'].has('weird-stream')).toBe(true);
      expect(typeof service['streamSubscriptions'].get('weird-stream')).toBe(
        'object',
      );
    });
  });

  describe('subscribeToLinkStream', () => {
    let errorSpy: jest.SpyInstance;
    beforeEach(() => {
      jest.clearAllMocks();
      errorSpy = jest.spyOn(logger, 'error');
    });
    afterEach(() => {
      errorSpy.mockRestore();
    });
    it('calls redisUtilityService.getAll', async () => {
      // Use a local variable for the mock to avoid unbound method errors
      const getAllMock = jest.fn().mockResolvedValue({});
      redisUtilityService.getAll = getAllMock;
      // Patch eventStream and getAllCheckpoints directly
      // @ts-expect-error: override for test
      service.eventStream = {
        catchup: jest.fn().mockResolvedValue(undefined),
        subscribe: jest.fn().mockReturnValue(undefined),
      };
      service['getAllCheckpoints'] = jest.fn().mockResolvedValue({});
      await service['subscribeToLinkStream']('test-stream');
      expect(getAllMock).toHaveBeenCalledWith(
        expect.anything(),
        expect.stringContaining('lookups:'),
      );
    });
    it('handles revision returned from eventStream.catchup', async () => {
      // @ts-expect-error: override for test
      service.eventStream = {
        catchup: jest.fn().mockResolvedValue(1n),
        subscribe: jest.fn().mockReturnValue(undefined),
      };
      service['getAllCheckpoints'] = jest.fn().mockResolvedValue({});
      service['catchupLink'] = { foo: { code: 'bar' } };
      const getAllMock = jest.fn().mockResolvedValue({});
      redisUtilityService.getAll = getAllMock;
      const writeMock = jest.fn().mockResolvedValue(undefined);
      redisUtilityService.write = writeMock;
      await service['subscribeToLinkStream']('test-stream');
      expect(writeMock).toHaveBeenCalled();
    });
    it('merges catchupLink into current when current already has the key', async () => {
      // @ts-expect-error: override for test
      service.eventStream = {
        catchup: jest.fn().mockResolvedValue(1n),
        subscribe: jest.fn().mockReturnValue(undefined),
      };
      service['getAllCheckpoints'] = jest.fn().mockResolvedValue({});
      service['catchupLink'] = { foo: { code: 'bar' } };
      // current already has 'foo'
      const getAllMock = jest.fn().mockResolvedValue({ foo: { code: 'baz' } });
      redisUtilityService.getAll = getAllMock;
      const writeMock = jest.fn().mockResolvedValue(undefined);
      redisUtilityService.write = writeMock;
      await service['subscribeToLinkStream']('test-stream');
      expect(writeMock).toHaveBeenCalled();
    });
    it('skips catchupLink merge when checkpoint equals revision', async () => {
      // @ts-expect-error: override for test
      service.eventStream = {
        catchup: jest.fn().mockResolvedValue(0n),
        subscribe: jest.fn().mockReturnValue(undefined),
      };
      service['getAllCheckpoints'] = jest.fn().mockResolvedValue({});
      service['catchupLink'] = { foo: { code: 'bar' } };
      const getAllMock = jest.fn().mockResolvedValue({});
      redisUtilityService.getAll = getAllMock;
      const writeMock = jest.fn().mockResolvedValue(undefined);
      redisUtilityService.write = writeMock;
      await service['subscribeToLinkStream']('test-stream');
      // writeMock should NOT be called, since the merge is skipped
      expect(writeMock).not.toHaveBeenCalled();
    });
    it('logs error if writing catchupLink fails (createLogContext branch)', async () => {
      // Setup catchupLink structure to trigger error path
      service['catchupLink'] = { key1: { code: 'c', name: 'n' } };
      service['catchup'] = {};
      (redisUtilityService.write as jest.Mock).mockRejectedValue(
        new Error('write fail'),
      );
      (redisUtilityService.getOne as jest.Mock).mockResolvedValue({ key1: {} });
      service['isShuttingDown'] = true;
      await service['subscribeToLinkStream']('foo');
      expect(errorSpy).toHaveBeenCalledWith(
        expect.objectContaining({}),
        expect.stringContaining('Failed to write catchup for key key1'),
      );
    });
    it('logs error with createLogContext if redisUtilityService.write fails during catchupLink merge', async () => {
      service['catchupLink'] = { testKey: { code: 'c1', name: 'n1' } };
      const current = { testKey: { existing: 'value' } };
      (redisUtilityService.write as jest.Mock).mockRejectedValueOnce(
        new Error('write fail'),
      );
      (redisUtilityService.getOne as jest.Mock).mockResolvedValue(current);
      service['isShuttingDown'] = true;
      await service['subscribeToLinkStream']('test-stream');
      expect(errorSpy).toHaveBeenCalledWith(
        expect.objectContaining({}),
        expect.stringContaining('Failed to write catchup for key testKey'),
      );
    });
  });

  describe('unsubscribeFromStream', () => {
    it('does nothing if stream is not active', () => {
      // Case 1: stream not in activeStreams
      service['activeStreams'] = new Set(['foo']);
      service['streamSubscriptions'] = new Map();
      expect(() => service['unsubscribeFromStream']('bar')).not.toThrow();
      expect(service['activeStreams'].has('foo')).toBe(true);

      // Case 2: stream in activeStreams but not in streamSubscriptions
      service['activeStreams'] = new Set(['baz']);
      service['streamSubscriptions'] = new Map();
      expect(() => service['unsubscribeFromStream']('baz')).not.toThrow();
      expect(service['activeStreams'].has('baz')).toBe(false);

      // Case 3: stream in streamSubscriptions but not in activeStreams
      const sub = new Subscription();
      service['activeStreams'] = new Set();
      service['streamSubscriptions'] = new Map([['qux', sub]]);
      expect(() => service['unsubscribeFromStream']('qux')).not.toThrow();
      expect(service['streamSubscriptions'].has('qux')).toBe(false);
    });
    describe('edge cases', () => {
      it('does nothing if stream is not in subscriptions or activeStreams', () => {
        service['activeStreams'] = new Set();
        service['streamSubscriptions'] = new Map();
        expect(() => {
          service['unsubscribeFromStream']('nonexistent');
        }).not.toThrow();
      });

      it('handles subscription without unsubscribe method', () => {
        service['activeStreams'] = new Set(['foo']);
        service['streamSubscriptions'] = new Map([['foo', {} as any]]) as any;
        expect(() => {
          service['unsubscribeFromStream']('foo');
        }).not.toThrow();
        expect(service['activeStreams'].has('foo')).toBe(false);
        expect(service['streamSubscriptions'].has('foo')).toBe(false); // should be removed
      });

      it('handles subscription object without unsubscribe method gracefully', () => {
        // Edge case: subscription object without unsubscribe method
        service['activeStreams'] = new Set(['edge']);
        // Create a mock object with no unsubscribe method
        const fakeSub = {} as unknown as Subscription;
        service['streamSubscriptions'] = new Map([['edge', fakeSub]]);
        expect(() => service['unsubscribeFromStream']('edge')).not.toThrow();
        expect(service['streamSubscriptions'].has('edge')).toBe(false);
        expect(service['activeStreams'].has('edge')).toBe(false);
      });
    });
  });

  describe('onModuleInit', () => {
    class TestableProjector extends EsdbRedisProjectorService {
      public async callSubscribeToLinkStream(
        ...args: Parameters<EsdbRedisProjectorService['subscribeToLinkStream']>
      ) {
        return this.subscribeToLinkStream(...args);
      }
    }
    let testableService: TestableProjector;
    beforeEach(() => {
      testableService = new TestableProjector(
        logger,
        eventStream as unknown as IEventStream<{
          id: string;
          type: string;
          payload: any;
        }>,
        redisUtilityService,
      );
    });
    it('subscribes to link stream', async () => {
      const spy = jest
        .spyOn(testableService as any, 'subscribeToLinkStream')
        .mockResolvedValue(undefined);
      await testableService.onModuleInit();
      expect(spy).toHaveBeenCalled();
    });
    it('logs error and context if subscribeToLinkStream throws', async () => {
      const error = new Error('fail-link');
      jest
        .spyOn(testableService as any, 'subscribeToLinkStream')
        .mockRejectedValue(error);
      const errorSpy = jest.spyOn(logger, 'error');
      await testableService.onModuleInit();
      expect(errorSpy).toHaveBeenCalled();
      const errorArgs = errorSpy.mock.calls[0][0];
      expect(errorArgs).toHaveProperty('method', 'onModuleInit');
      expect(errorArgs).toHaveProperty(
        'component',
        testableService['projectorLinkStream'],
      );
      expect(errorArgs).toHaveProperty('errorName', 'Error');
      expect(errorArgs).toHaveProperty('errorMessage', 'fail-link');
    });
  });

  describe('onModuleDestroy', () => {
    it('unsubscribes all streams', () => {
      // Use real Subscription objects for type safety
      const sub1 = new Subscription();
      const sub2 = new Subscription();
      const unsub1 = jest.spyOn(sub1, 'unsubscribe');
      const unsub2 = jest.spyOn(sub2, 'unsubscribe');
      service['streamSubscriptions'] = new Map([
        ['foo', sub1],
        ['bar', sub2],
      ]);
      service['onModuleDestroy']();
      expect(unsub1).toHaveBeenCalled();
      expect(unsub2).toHaveBeenCalled();
      expect(service['streamSubscriptions'].size).toBe(0);
    });
    describe('edge cases', () => {
      it('does nothing if no subscriptions', () => {
        service['streamSubscriptions'] = new Map();
        expect(() => service.onModuleDestroy()).not.toThrow();
      });
    });
  });

  // Utility method coverage (if these methods exist and are not covered)
  describe('utility methods', () => {
    it('getAllCheckpoints returns a promise', async () => {
      if (typeof service['getAllCheckpoints'] === 'function') {
        const result = await service['getAllCheckpoints']();
        expect(result).toBeDefined();
      }
    });
    describe('edge cases', () => {
      it('getAllCheckpoints handles empty redis response', async () => {
        (redisUtilityService.getAll as jest.Mock).mockResolvedValue(undefined);
        const result = await service['getAllCheckpoints']();
        expect(result).toEqual({});
      });
    });
  });

  describe('writeCatchupData', () => {
    it('logs error if write fails', async () => {
      // Setup catchup structure to trigger error path
      service['catchup'] = { foo: { t: { k: { some: 'data' } } } };
      (redisUtilityService.write as jest.Mock).mockRejectedValue(
        new Error('write fail'),
      );
      await service['writeCatchupData']('foo');
      expect((logger.error as jest.Mock).mock.calls.length).toBeGreaterThan(0);
    });
  });

  describe('handleLinkEvent', () => {
    it('logs error if event processing fails', async () => {
      // Pass data with __simulateError: true to trigger error path
      await service['handleLinkEvent'](
        { __simulateError: true },
        {
          stream: 'foo',
          tenant: 't',
          key: 'k',
          type: 'test',
          date: new Date(),
          sequence: 1n,
          revision: 1n,
          isLive: false,
        },
      );
      expect((logger.error as jest.Mock).mock.calls.length).toBeGreaterThan(0);
    });
  });

  describe('ILogger static helpers', () => {
    class TestProjector extends EsdbRedisProjectorService {
      public testCreateLogContext(
        ...args: Parameters<EsdbRedisProjectorService['createLogContext']>
      ) {
        return this.createLogContext(...args);
      }
      public testCreateErrorContext(
        ...args: Parameters<EsdbRedisProjectorService['createErrorContext']>
      ) {
        return this.createErrorContext(...args);
      }
    }
    const testService = new TestProjector(
      logger,
      eventStream as unknown as IEventStream<{
        id: string;
        type: string;
        payload: any;
      }>,
      redisUtilityService,
    );
    it('createLogContext returns expected structure', () => {
      const ctx = testService.testCreateLogContext(
        'myMethod',
        'MyComponent',
        'op-123',
        { stream: 'myStream' },
      );
      expect(ctx).toMatchObject({
        operationId: 'op-123',
        method: 'myMethod',
        stream: 'myStream',
        component: 'MyComponent',
      });
      // Should generate a UUID if no operationId is provided
      const ctx2 = testService.testCreateLogContext('otherMethod');
      expect(ctx2).toHaveProperty('operationId');
      expect(ctx2.method).toBe('otherMethod');
      expect(ctx2.component).toBe('Service');
      // Should handle undefined stream/component
      const ctx3 = testService.testCreateLogContext('m');
      expect(ctx3.stream).toBeUndefined();
      expect(ctx3.component).toBe('Service');
      // Should be serializable
      expect(() => JSON.stringify(ctx)).not.toThrow();
    });
    it('createErrorContext returns expected structure', () => {
      const base = testService.testCreateLogContext(
        'failMethod',
        'failStream',
        'FailComponent',
        { stream: 'myStream' },
      );
      const err = new Error('fail!');
      const ctx = testService.testCreateErrorContext(base, err, { foo: 1 });
      expect(ctx).toMatchObject({
        ...base,
        errorName: 'Error',
        errorMessage: 'fail!',
        props: { foo: 1 },
      });
      expect(ctx.stack).toBeDefined();
      // Non-Error input
      const ctx2 = testService.testCreateErrorContext(base, 'fail string');
      expect(ctx2.errorName).toBe('string');
      expect(ctx2.errorMessage).toBe('fail string');
      expect(ctx2.stack).toBeUndefined();
      // No props
      const ctx3 = testService.testCreateErrorContext(base, err);
      expect(ctx3).not.toHaveProperty('props');
      // Non-object error
      const ctx4 = testService.testCreateErrorContext(base, 123);
      expect(ctx4.errorName).toBe('number');
      expect(ctx4.errorMessage).toBe('123');
      // Should be serializable
      expect(() => JSON.stringify(ctx)).not.toThrow();
    });
  });

  describe('subscribeToLinkStream (error-path eventStream injection)', () => {
    let errorSpy: jest.SpyInstance;
    let customService: EsdbRedisProjectorService;
    let customRedisUtilityService: RedisUtilityService;
    let customLogger: ILogger;
    beforeEach(async () => {
      jest.clearAllMocks();
      errorSpy = jest.fn();
      const customEventStream = {
        catchup: jest.fn().mockResolvedValue(2n),
        subscribe: jest.fn().mockReturnValue(undefined),
      };
      const module: TestingModule = await Test.createTestingModule({
        providers: [
          EsdbRedisProjectorService,
          {
            provide: RedisUtilityService,
            useValue: {
              getOne: jest.fn(),
              write: jest.fn(),
              getAll: jest.fn(),
              deleteCategoryAndEntities: jest.fn(),
              deleteCheckpoint: jest.fn(),
            },
          },
          {
            provide: 'ILogger',
            useValue: {
              log: jest.fn(),
              warn: jest.fn(),
              error: errorSpy,
              debug: jest.fn(),
              verbose: jest.fn(),
            },
          },
          {
            provide: 'MANAGEMENT_EVENTS_STREAM',
            useValue: customEventStream,
          },
        ],
      }).compile();
      customService = module.get<EsdbRedisProjectorService>(
        EsdbRedisProjectorService,
      );
      customRedisUtilityService =
        module.get<RedisUtilityService>(RedisUtilityService);
      customLogger = module.get<ILogger>('ILogger');
    });
    afterEach(() => {
      jest.clearAllMocks();
    });
    it('logs error if writing catchupLink fails (createLogContext branch)', async () => {
      customService['catchupLink'] = { key1: { code: 'c', name: 'n' } };
      customService['catchup'] = {};
      (customRedisUtilityService.write as jest.Mock).mockRejectedValue(
        new Error('write fail'),
      );
      (customRedisUtilityService.getOne as jest.Mock).mockResolvedValue({
        key1: {},
      });
      customService['isShuttingDown'] = true;
      await customService['subscribeToLinkStream']('foo');
      expect(errorSpy).toHaveBeenCalledWith(
        expect.objectContaining({}),
        expect.stringContaining('Failed to write catchup for key key1'),
      );
    });
    it('logs error with createLogContext if redisUtilityService.write fails during catchupLink merge', async () => {
      customService['catchupLink'] = { testKey: { code: 'c1', name: 'n1' } };
      const current = { testKey: { existing: 'value' } };
      (customRedisUtilityService.write as jest.Mock).mockRejectedValueOnce(
        new Error('write fail'),
      );
      (customRedisUtilityService.getOne as jest.Mock).mockResolvedValue(
        current,
      );
      customService['isShuttingDown'] = true;
      await customService['subscribeToLinkStream']('test-stream');
      expect(errorSpy).toHaveBeenCalledWith(
        expect.objectContaining({}),
        expect.stringContaining('Failed to write catchup for key testKey'),
      );
    });
  });
});
